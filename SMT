///**
//  ******************************************************************************
//  * @file    main.c
//  * @author  Weili An
//  * @version V1.0
//  * @date    Nov 15, 2022
//  * @brief   ECE 362 Lab 10 Student template
//  ******************************************************************************
//*/
//
//
//#include "stm32f0xx.h"
//#include "lcd.h"
//
//
//// Be sure to change this to your login...
//const char login[] = "bhandarm";
//
//void set_char_msg(int, char);
//void nano_wait(unsigned int);
//
//
//
//static const uint16_t array[] = {};
////===========================================================================
//// Configure GPIOC
////===========================================================================
//void enable_ports(void) {
//    // Only enable port C for the keypad
//    RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
//    GPIOC->MODER &= ~0xffff;
//    GPIOC->MODER |= 0x55 << (4*2);
//    GPIOC->OTYPER &= ~0xff;
//    GPIOC->OTYPER |= 0xf0;
//    GPIOC->PUPDR &= ~0xff;
//    GPIOC->PUPDR |= 0x55;
//}
//
//uint8_t col; // the column being scanned
//
//void drive_column(int);   // energize one of the column outputs
//int  read_rows();         // read the four row inputs
//void update_history(int col, int rows); // record the buttons of the driven column
//char get_key_event(void); // wait for a button event (press or release)
//char get_keypress(void);  // wait for only a button press event.
//float getfloat(void);     // read a floating-point number from keypad
//void show_keys(void);     // demonstrate get_key_event()
//
////===========================================================================
//// Configure timer 7 to invoke the update interrupt at 1kHz
//// Copy from lab 8 or 9.
////===========================================================================
//void init_tim7(void) {
//    RCC -> APB1ENR |= RCC_APB1ENR_TIM7EN;
//
//    TIM7 -> PSC = 48 - 1;
//    // 48000000 / 4800 = 10000
//    //10000 / 10 = 1kHZ
//    // we want it to occur every one second
//    TIM7 -> ARR = 1000 - 1;
//    TIM7 -> DIER |= 0b1;
//
//    TIM7 -> CR1 |= 0b1;
//
//    NVIC->ISER[0] |= 1 << 18;
//
//}
//
////===========================================================================
//// Copy the Timer 7 ISR from lab 9
////===========================================================================
//void TIM7_IRQHandler()
//
//{
//    // First ack the interrupt
//    TIM7->SR &= ~TIM_SR_UIF;
//
//    int rows = read_rows();
//    update_history(col, rows);
//    col = (col + 1) & 3;
//    drive_column(col);
//}
//
//
////===========================================================================
//// 4.1 Bit Bang SPI LED Array
////===========================================================================
//int msg_index = 0;
//uint16_t msg[8] = { 0x0000,0x0100,0x0200,0x0300,0x0400,0x0500,0x0600,0x0700 };
//extern const char font[];
//
////===========================================================================
//// Configure PB12 (NSS), PB13 (SCK), and PB15 (MOSI) for outputs
////===========================================================================
//void setup_bb(void) {
//    RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
//
//    GPIOB -> MODER |= GPIO_MODER_MODER12_0;
//    GPIOB -> MODER &= ~GPIO_MODER_MODER12_1;
//
//    GPIOB -> MODER |= GPIO_MODER_MODER13_0;
//    GPIOB -> MODER &= ~GPIO_MODER_MODER13_1;
//
//    GPIOB -> MODER |= GPIO_MODER_MODER15_0;
//    GPIOB -> MODER &= ~GPIO_MODER_MODER15_1;
//
//    GPIOB -> ODR &= ~0x3000;
//    GPIOB -> ODR |= 0x1000;
//
//
//}
//
//void small_delay(void) {
//    nano_wait(50000);
//}
//
////===========================================================================
//// Set the MOSI bit, then set the clock high and low.
//// Pause between doing these steps with small_delay().
////===========================================================================
//void bb_write_bit(int val) {
//    // NSS (PB12)
//    // SCK (PB13)
//    // MOSI (PB15)
//    GPIOB -> ODR &= ~0x8000;
//    GPIOB -> ODR |= val << 15;
//
//    small_delay();
//    GPIOB -> ODR |= 0x2000;
//
//    small_delay();
//    GPIOB -> ODR &= ~0x2000;
//}
//
////===========================================================================
//// Set NSS (PB12) low,
//// write 16 bits using bb_write_bit,
//// then set NSS high.
////===========================================================================
//void bb_write_halfword(int halfword) {
//    int shifted;
//    GPIOB -> ODR &= ~0x1000;
//
//    for(int i = 15; i >= 0; i--){
//        shifted = halfword >> i;
//        shifted = shifted & 0x1;
//        bb_write_bit(shifted);
//
//    }
//
//    //NSS to high
//    GPIOB -> ODR |= 0x1000;
//
//}
//
////===========================================================================
//// Continually bitbang the msg[] array.
////===========================================================================
//void drive_bb(void) {
//    for(;;)
//        for(int d=0; d<8; d++) {
//            bb_write_halfword(msg[d]);
//            nano_wait(1000000); // wait 1 ms between digits
//        }
//}
//
////============================================================================
//// setup_dma()
//// Copy this from lab 8 or lab 9.
//// Write to SPI2->DR instead of GPIOB->ODR.
////============================================================================
//void setup_dma(void)
//
//{
//    // DMA1 Channel 5 works with TIM15 interrupt
//    RCC->AHBENR         |=           RCC_AHBENR_DMA1EN;
//    DMA1_Channel5->CCR  &= ~DMA_CCR_EN;
//    DMA1_Channel5->CPAR  =  (uint32_t)(&(SPI2 -> DR));
//
//    DMA1_Channel5->CMAR  =  (uint32_t) msg;
//
//    DMA1_Channel5->CNDTR =  8;
//    DMA1_Channel5->CCR  |=     DMA_CCR_DIR;
//    DMA1_Channel5->CCR  |=     DMA_CCR_MINC;
//    DMA1_Channel5->CCR  &= ~DMA_CCR_MSIZE;
//    DMA1_Channel5->CCR  |=     DMA_CCR_MSIZE_0;
//    DMA1_Channel5->CCR  &= ~DMA_CCR_PSIZE;
//    DMA1_Channel5->CCR  |=     DMA_CCR_PSIZE_0;
//    DMA1_Channel5->CCR  |=     DMA_CCR_CIRC;
//
//}
//
////============================================================================
//// enable_dma()
//// Copy this from lab 8 or lab 9.
////============================================================================
//void enable_dma(void)
//
//{
//
//    DMA1_Channel5->CCR |= DMA_CCR_EN;
//
//}
//
////============================================================================
//// Configure Timer 15 for an update rate of 1 kHz.
//// Trigger the DMA channel on each update.
//// Copy this from lab 8 or lab 9.
////============================================================================
//void init_tim15(void) {
//    RCC -> APB2ENR |= RCC_APB2ENR_TIM15EN;
//
//    TIM15 -> PSC = 48 - 1;
//    // 48000000 / 4800 = 10000
//    //10000 / 10 = 1kHZ
//    // we want it to occur every one second
//    TIM15 -> ARR = 1000 - 1;
//    TIM15 -> DIER |= TIM_DIER_UDE;
//
//    TIM15 -> CR1 |= 0b1;
//
//}
//
////===========================================================================
//// Initialize the SPI2 peripheral.
////===========================================================================
///*
//Ensure that the CR1_SPE bit is clear. Many of the bits set in the control registers require that the SPI channel is not enabled.
//
//Set the baud rate as low as possible (maximum divisor for BR).
//
//Configure the interface for a 16-bit word size.
//
//Configure the SPI channel to be in â€œmaster modeâ€�.
//
//Set the SS Output enable bit and enable NSSP.
//
//Set the TXDMAEN bit to enable DMA transfers on transmit buffer empty
//
//Enable the SPI channel.
//*/
//
//void init_spi2(void) {
//    RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
//    // set PB12, 13, 15 into AF
//    GPIOB -> MODER &= ~GPIO_MODER_MODER12_0;
//    GPIOB -> MODER |= GPIO_MODER_MODER12_1;
//
//    GPIOB -> MODER &= ~GPIO_MODER_MODER13_0;
//    GPIOB -> MODER |= GPIO_MODER_MODER13_1;
//
//    GPIOB -> MODER &= ~GPIO_MODER_MODER15_0;
//    GPIOB -> MODER |= GPIO_MODER_MODER15_1;
//
//
//
//    GPIOB -> AFR[1] &= ~0xF0FF0000;
//
//    // SPI2 enable
//    RCC -> APB1ENR |= RCC_APB1ENR_SPI2EN;
//
//    // clears CR1_SPE for 15, 13, 12 to AF0
//    SPI2 -> CR1 &= ~SPI_CR1_SPE;
//
//    // set BR
//    SPI2 -> CR1 |= SPI_CR1_BR;
//
//    // set DR (DATA SIZE) to 16 bit 1111
//    SPI2 -> CR2 |= 0xF00;
//
//    // MASTER MODE MSTR page 790
//    SPI2 -> CR1 |= 0x4;
//
//    // set bit 2 to enable (SS output SSOE) set bit 3 to enable (NSSP on)
//    SPI2 -> CR2 |= 0xC;
//
//    // set bit1 to enable TXDMAEN
//    SPI2 -> CR2 |= 0x2;
//
//    //ENABLE the SPI channel
//    SPI2 -> CR1 |= SPI_CR1_SPE;
//
//}
//
////===========================================================================
//// Configure the SPI2 peripheral to trigger the DMA channel when the
//// transmitter is empty.
////===========================================================================
//void spi2_setup_dma(void) {
//    setup_dma();
//    SPI2->CR2 |= SPI_CR2_TXDMAEN; // Transfer register empty DMA enable
//}
//
////===========================================================================
//// Enable the DMA channel.
////===========================================================================
//void spi2_enable_dma(void) {
//    enable_dma();
//}
//
////===========================================================================
//// 4.4 SPI OLED Display
////===========================================================================
//
///*
//Configure NSS, SCK, MISO and MOSI signals of SPI1 to pins PA15, PA5, PA6, and PA7, respectively.
//
//Configure the SPI registers 10-bit word size.
//
//Enable it.
//*/
//
//void init_spi1() {
//    // PA5  SPI1_SCK
//    // PA6  SPI1_MISO
//    // PA7  SPI1_MOSI
//    // PA15 SPI1_NSS
//
//    RCC -> AHBENR = RCC_AHBENR_GPIOAEN;
//    RCC -> APB2ENR |= RCC_APB2ENR_SPI1EN;
//
//
//
//    SPI1 -> CR1 &= ~SPI_CR1_SPE;
//
//    // SET TO AF MODE
//    GPIOA -> MODER &= ~GPIO_MODER_MODER5;
//    GPIOA -> MODER |= GPIO_MODER_MODER5_1;
//
//    GPIOA -> MODER &= ~GPIO_MODER_MODER6;
//    GPIOA -> MODER |= GPIO_MODER_MODER6_1;
//
//    GPIOA -> MODER &= ~GPIO_MODER_MODER7;
//    GPIOA -> MODER |= GPIO_MODER_MODER7_1;
//
//    GPIOA -> MODER &= ~GPIO_MODER_MODER15;
//    GPIOA -> MODER |= GPIO_MODER_MODER15_1;
//
//    GPIOA -> AFR[0] &= ~0xFFF00000;
//    GPIOA -> AFR[1] &= ~0xF0000000;
//
//
//    // set DS (DATA SIZE) to 10 bit 1001
//    //SPI1 -> CR2 &= ~0xF00;
//    SPI1 -> CR2 = SPI_CR2_DS_3 | SPI_CR2_DS_0;
//
//    // MASTER MODE MSTR page 790
//    SPI1 -> CR1 |= SPI_CR1_MSTR;
//
//    SPI1 -> CR1 |= SPI_CR1_BR;
//
//
//    // set bit 2 to enable (SS output SSOE) set bit 3 to enable (NSSP on)
//    SPI1 -> CR2 |= SPI_CR2_SSOE;
//    SPI1 -> CR2 |= SPI_CR2_NSSP;
//
//
//
//    // set bit1 to enable TXDMAEN
//    SPI1 -> CR2 |= SPI_CR2_TXDMAEN;
//
//    //ENABLE the SPI channel
//    SPI1 -> CR1 |= SPI_CR1_SPE;
//
//
//}
//
//void spi_cmd(unsigned int data) {
//    while(!(SPI1->SR & SPI_SR_TXE)) {}
//    SPI1->DR = data;
//}
//void spi_data(unsigned int data) {
//    spi_cmd(data | 0x200);
//}
//void spi1_init_oled() {
//    nano_wait(1000000);
//    spi_cmd(0x38);
//    spi_cmd(0x08);
//    spi_cmd(0x01);
//    nano_wait(2000000);
//    spi_cmd(0x06);
//    spi_cmd(0x02);
//    spi_cmd(0x0c);
//}
//void spi1_display1(const char *string) {
//    spi_cmd(0x02);
//    while(*string != '\0') {
//        spi_data(*string);
//        string++;
//    }
//}
//void spi1_display2(const char *string) {
//    spi_cmd(0xc0);
//    while(*string != '\0') {
//        spi_data(*string);
//        string++;
//    }
//}
//
////===========================================================================
//// This is the 34-entry buffer to be copied into SPI1.
//// Each element is a 16-bit value that is either character data or a command.
//// Element 0 is the command to set the cursor to the first position of line 1.
//// The next 16 elements are 16 characters.
//// Element 17 is the command to set the cursor to the first position of line 2.
////===========================================================================
//uint16_t display[34] = {
//        0x002, // Command to set the cursor at the first position line 1
//        0x200+'E', 0x200+'C', 0x200+'E', 0x200+'3', 0x200+'6', + 0x200+'2', 0x200+' ', 0x200+'i',
//        0x200+'s', 0x200+' ', 0x200+'t', 0x200+'h', + 0x200+'e', 0x200+' ', 0x200+' ', 0x200+' ',
//        0x0c0, // Command to set the cursor at the first position line 2
//        0x200+'c', 0x200+'l', 0x200+'a', 0x200+'s', 0x200+'s', + 0x200+' ', 0x200+'f', 0x200+'o',
//        0x200+'r', 0x200+' ', 0x200+'y', 0x200+'o', + 0x200+'u', 0x200+'!', 0x200+' ', 0x200+' ',
//};
//
////===========================================================================
//// Configure the proper DMA channel to be triggered by SPI1_TX.
//// Set the SPI1 peripheral to trigger a DMA when the transmitter is empty.
////===========================================================================
//void spi1_setup_dma(void) {
//    // compy from lab 8/9
//    RCC->AHBENR         |=           RCC_AHBENR_DMA1EN;
//    // channel 3 because we want SPI1 TX (transmitter)
//    DMA1_Channel3->CCR  &= ~DMA_CCR_EN;
//    DMA1_Channel3->CPAR  =  (uint32_t)(&(SPI1 -> DR));
//
//    DMA1_Channel3->CMAR  =  (uint32_t) (&(display));
//
//    //34 entries
//    DMA1_Channel3->CNDTR =  34;
//    DMA1_Channel3->CCR  |=     DMA_CCR_DIR;
//    DMA1_Channel3->CCR  |=     DMA_CCR_MINC;
//    DMA1_Channel3->CCR  &= ~DMA_CCR_MSIZE;
//    DMA1_Channel3->CCR  |=     DMA_CCR_MSIZE_0;
//    DMA1_Channel3->CCR  &= ~DMA_CCR_PSIZE;
//    DMA1_Channel3->CCR  |=     DMA_CCR_PSIZE_0;
//    DMA1_Channel3->CCR  |=     DMA_CCR_CIRC;
//
//
//}
//
////===========================================================================
//// Enable the DMA channel triggered by SPI1_TX.
////===========================================================================
//void spi1_enable_dma(void) {
//    DMA1_Channel3 -> CCR |= DMA_CCR_EN;
//
//}
//
////===========================================================================
//// Main function
////===========================================================================
//
//int main(void) {
//    msg[0] |= font['E'];
//    msg[1] |= font['C'];
//    msg[2] |= font['E'];
//    msg[3] |= font[' '];
//    msg[4] |= font['4'];
//    msg[5] |= font['7'];
//    msg[6] |= font['7'];
//    msg[7] |= font[' '] | ~0b01111111;
//    //msg[7] |= 0x80;
//    		//int32_t x = GPIOB -> ODR;
//
//    // This time, autotest always runs as an invisible aid to you.
//    //autotest();
//
//    // GPIO enable
//    enable_ports();
//    // setup keyboard
//    init_tim7();
//
//    // LED array Bit Bang
//#define BIT_BANG
//#if defined(BIT_BANG)
//    setup_bb();
//    drive_bb();
//#endif
//
//    // Direct SPI peripheral to drive LED display
////#define SPI_LEDS
//#if defined(SPI_LEDS)
//    init_spi2();
//    setup_dma();
//    enable_dma();
//    init_tim15();
//    show_keys();
//#endif
//
//    // LED array SPI
////#define SPI_LEDS_DMA
//#if defined(SPI_LEDS_DMA)
//    init_spi2();
//    spi2_setup_dma();
//    spi2_enable_dma();
//    show_keys();
//#endif
//
//    // SPI OLED direct drive
////#define SPI_OLED
//#if defined(SPI_OLED)
//    init_spi1();
//    spi1_init_oled();
//    spi1_display1("Hello again,");
//    spi1_display2(login);
//    //for(;;) {}
//#endif
//
//    // SPI
////#define SPI_OLED_DMA
//#if defined(SPI_OLED_DMA)
//    init_spi1();
//    spi1_init_oled();
//    spi1_setup_dma();
//    spi1_enable_dma();
//    //for(;;) {}
//#endif
//
//    // Game on!  The goal is to score 100 points.
//    // LCD
////#define LCD
//#if defined(LCD)
//  LCD_Setup();
//  LCD_Clear(0x0000); // If the screen turns black, that means it's working.
//  // Insert your picture code here...
//  int point = 0;
//  for(int i = 0; i < 320; i++){
//    for(int j = 0; j < 240; j++){
//        LCD_DrawPoint(j, i, array[i*320 + point]);
//        point++;
//    }
//    point = 0;
//  }
//#endif
//
//    //game();
//}


/**
  ******************************************************************************
  * @file    main.c
  * @author  Weili An
  * @version V1.0
  * @date    Nov 15, 2022
  * @brief   ECE 362 Lab 10 Student template
  ******************************************************************************
*/


#include "stm32f0xx.h"
#include <stdio.h>
#include <stdlib.h>

char dig_char[] = "0123456789ABCDEF";


struct node
{
    int data;
    struct node *next;
};

struct node *front = NULL;
struct node *rear = NULL;

//void display();
void enqueue(int);
int dequeue();

// Be sure to change this to your login...
const char login[] = "xyz";

// how many rand values you want
int sequence_len = 2;


void set_char_msg(int, char);
void nano_wait(unsigned int);


//===========================================================================
// Configure GPIOC
//===========================================================================
void enable_ports(void)
{
    // Only enable port C for the keypad. Given.
    RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
    GPIOC->MODER &= ~0xffff;
    GPIOC->MODER |= 0x55 << (4*2);
    GPIOC->OTYPER &= ~0xff;
    GPIOC->OTYPER |= 0xf0;
    GPIOC->PUPDR &= ~0xff;
    GPIOC->PUPDR |= 0x55;
}

uint8_t col; // the column being scanned

void drive_column(int);   // energize one of the column outputs
int  read_rows();         // read the four row inputs
void update_history(int col, int rows); // record the buttons of the driven column
char get_key_event(); // wait for a button event (press or release)
char get_keypress(void);  // wait for only a button press event.
float getfloat(void);     // read a floating-point number from keypad
void show_keys(void);     // demonstrate get_key_event()

//===========================================================================
// Configure timer 7 to invoke the update interrupt at 1kHz
// Copy from lab 8 or 9.
//===========================================================================
void init_tim7()
{
  // Turn on clock, can write
  // 0x20 instead
  RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;

  // Configure to run at 1kHz
  TIM7->PSC = 48-1;
  TIM7->ARR = 1000-1;

  // Enable the interrupt,
  // can write 0x01 instead
  TIM7->DIER |= TIM_DIER_UIE;

  // Unmask the interrupt
  NVIC->ISER[0] |= 1<<TIM7_IRQn;

  // Enable timer, can write
  // 0x01 instead
  TIM7->CR1 |= TIM_CR1_CEN;
}

//===========================================================================
// Copy the Timer 7 ISR from lab 9
//===========================================================================
// TODO To be copied
void TIM7_IRQHandler(void)
{
  // Code is given in lab 9
  TIM7->SR &= ~TIM_SR_UIF;
  int rows = read_rows();
  update_history(col, rows);
  col = (col + 1) & 3;
  drive_column(col);
}

//===========================================================================
// 4.1 Bit Bang SPI LED Array
//===========================================================================
// Given
int msg_index = 0;
uint16_t msg[8] = { 0x0000,0x0100,0x0200,0x0300,0x0400,0x0500,0x0600,0x0700 };
extern const char font[];

//===========================================================================
// Configure PB12 (NSS), PB13 (SCK), and PB15 (MOSI) for outputs
//===========================================================================
void setup_bb(void)
{
  // Turn on GPIOB
  RCC->AHBENR |= RCC_AHBENR_GPIOBEN;

  // Set 12, 13, 15 to output mode,
  // Can also clear out and write in
  // GPIO_MODER_MODER15_0 |
  // GPIO_MODER_MODER13_0 |
  // GPIO_MODER_MODER12_0 instead.
  // Should come out to 0x45000000 at
  // the end either way.
  GPIOB->MODER &= ~0xcf000000;
  GPIOB->MODER |=  0x45000000;

  // Force PB12 high, force PB13
  // and PB15 low. PB15 does not
  // "need" to be low,
  // but it's good practice. They
  // can also write 0xa0001000 to
  // this to get the
  // same effect.
  GPIOB->BSRR |= GPIO_BSRR_BS_12 | GPIO_BSRR_BR_13 | GPIO_BSRR_BR_15;


  // **** NOTE ****
  // I'm going to use the BSRR for
  //all of these operations. This is
  // the "better practice" way to do
  // it, but they can also use the ODR.
  // In that case, the hex codes will
  // come out very similarly, just
  // shifted down 16 bits in the
  // case of bit reset operations.
  // For example, GPIO->BSRR |= 0x100000000; is
  // Equivalent to GPIO->ODER &- ~0x1000;
  // **** END ****
}

void small_delay(void)
{
  // Given.
  nano_wait(50000);
}

//===========================================================================
// Set the MOSI bit, then set the clock high and low.
// Pause between doing these steps with small_delay().
//===========================================================================
void bb_write_bit(int val)
{
  // NSS (PB12)
  // SCK (PB13)
  // MOSI (PB15)

  // If value is zero, force PB15 low.
  // If value is nonzero, force PB15 high.

  if(val == 0)
  {
    // Can also write in 0x80000000
    GPIOB->BSRR |= GPIO_BSRR_BR_15;
  }
  else
  {
    // Can also write in 0x00008000
    GPIOB->BSRR |= GPIO_BSRR_BS_15;
  }

  // Force PB13 high, wait, force PB13 low,
  // wait. Can also use
  // 0x00002000 and 0x20000000
  GPIOB->BSRR |= GPIO_BSRR_BS_13;
  small_delay();
  GPIOB->BSRR |= GPIO_BSRR_BR_13;
  small_delay();

}

//===========================================================================
// Set NSS (PB12) low,
// write 16 bits using bb_write_bit,
// then set NSS high.
//===========================================================================
void bb_write_halfword(int halfword)
{
  // They can do this two ways. Shift
  // right and count down, or shift left
  // and count up. The lab does tell them
  // to shift right, but it works either way.
  // For this example, I shift right. If
  // they shift left, change i to 0
  // and do i++ instead of i--, then
  // AND with 0x8000000 instead of 0x1.

  // Start by forcing PB12 low. Can also use
  // 0x100000000
  GPIOB->BSRR |= GPIO_BSRR_BR_12;

  // For loop that goes through the half word.
  for(int i = 15 ; i >=0 ; i--)
  {
      // Shift by (15-loop_iteration), take
      // leftover bit into function
      bb_write_bit(((halfword>>i) & 0x1));
  }

  // Force PB12 high again. Can also use
  // 0x00001000
  GPIOB->BSRR |= GPIO_BSRR_BS_12;
}

//===========================================================================
// Continually bitbang the msg[] array.
//===========================================================================
void drive_bb(void)
{
  // Given.
    for(;;)
        for(int d=0; d<8; d++) {
            bb_write_halfword(msg[d]);
            nano_wait(1000000); // wait 1 ms between digits
        }
}

//============================================================================
// setup_dma()
// Copy this from lab 8 or lab 9.
// Write to SPI2->DR instead of GPIOB->ODR.
//============================================================================
void setup_dma(void)
{
  // Turn on DMA1
  RCC->AHBENR |= RCC_AHBENR_DMA1EN;

  // Configure DMA. They should be using channel 5.

  // Turn off DMA
  // CPAR to SPI2 DR adr
  // CMAR to msg adr
  // 8 units in array
  // mem to per direction
  // Increment mem adr
  // no inc per adr
  // Set data size to 16b
  // Operate circularly
  DMA1_Channel5->CCR &= ~DMA_CCR_EN;
  DMA1_Channel5->CPAR = (uint32_t) &(SPI2->DR);
  DMA1_Channel5->CMAR = (uint32_t) &(msg);
  DMA1_Channel5->CNDTR = 8;
  DMA1_Channel5->CCR |= DMA_CCR_DIR;
  DMA1_Channel5->CCR |= DMA_CCR_MINC;
  DMA1_Channel5->CCR &= ~DMA_CCR_PINC;
  DMA1_Channel5->CCR |= 0x0500;
  DMA1_Channel5->CCR |= DMA_CCR_CIRC;

  //**** NOTE ****
  // After this task, these hex codes should be visible if you put
  // in a breakpoint:
  // CCR  -> 0x05b0
  // CPAR -> 0x4000380C
  // CNDTR-> 0x00008
  // CMAR -> Varies depending on how the compiler organizes it. No set address.
  //         Should be in the 0x20000000 range though, because that's where
  //         the memory is.
  //**** END ****
}

//============================================================================
// enable_dma()
// Copy this from lab 8 or lab 9.
//============================================================================
void enable_dma(void)
{
  // Enable the DMA.
  DMA1_Channel5->CCR |= DMA_CCR_EN;

  //**** NOTE ****
  // After this task, the CCR hex code
  // should change to 0x05b1 if you put a
  // breakpoint here.
  //**** END ****
}

//============================================================================
// Configure Timer 15 for an update rate of 1 kHz.
// Trigger the DMA channel on each update.
// Copy this from lab 8 or lab 9.
//============================================================================
void init_tim15(void)
{
  // Turn timer's clock on,
  // can write 0x0001000 instead
  RCC->APB2ENR |= RCC_APB2ENR_TIM15EN;

  // Turn timer off, can write
  // 0x0001 instead.
  TIM15->CR1 &= ~TIM_CR1_CEN;

  // Configure PSC and ARR to
  // 1kHz
  TIM15->PSC = 48-1;
  TIM15->ARR = 1000-1;

  // Trigger the DMA transfer,
  // can write 0x0100 instead.
  TIM15->DIER |= TIM_DIER_UDE;

  // Turn timer on, can write
  // 0x0001 instead.
  TIM15->CR1 |= TIM_CR1_CEN;
}

//===========================================================================
// Initialize the SPI2 peripheral.
//===========================================================================
void init_spi2(void)
{
  // Enable port B, can write
  // 0x00004000 instead
  RCC->AHBENR |= RCC_AHBENR_GPIOBEN;

  // Set PB12, 13, 15 into AF mode.
  // Like earlier, they can use the
  // CMSIS calls.
  GPIOB->MODER &= ~0xcf000000;
  GPIOB->MODER |=  0x8a000000;

  // These pins default alternate
  // functions are the SPI function.
  // However, they can clear them out
  // if they want. It doesn't make a
  // difference.
  // These CMSIS calls look like
  // (GPIO_AFRH_AFR12 | GPIO_AFRH_AFR13
  // | GPIO_AFRH_AFR15).
  GPIOB->AFR[1] &= ~0xf0ff0000;

  // Turn on RCC clock,
  // can write 0x00004000 instead.
  RCC->APB1ENR |= RCC_APB1ENR_SPI2EN;

  // Turn off the channel
  // for configuration, can write 0x0040
  SPI2->CR1 &= ~SPI_CR1_SPE;

  // Turn baud rate to lowest,
  // can write 0x0038 instead
  SPI2->CR1 |= SPI_CR1_BR;

  // Set data size to 16 bit,
  // can write 0x0f00 instead
  SPI2->CR2 |= SPI_CR2_DS;

  // Turn on master mode,
  // can write 0x0004 instead
  SPI2->CR1 |= SPI_CR1_MSTR;

  // Enable SSOE and NSSP,
  // can write 0x000c instead
  SPI2->CR2 |= SPI_CR2_SSOE | SPI_CR2_NSSP;

  // Trigger a DMA transfer,
  // can write 0x0002 instead
  SPI2->CR2 |= SPI_CR2_TXDMAEN;

  // Turn the spi channel back on,
  // can write 0x0040 instead
  SPI2->CR1 |= SPI_CR1_SPE;

  //**** NOTE ****
  // After this block, if you put a
  // breakpoint here the registers should look
  // like this:
  // CR1 -> 0x007c
  // CR2 -> 0x0f0e
  //**** END ****
}

//===========================================================================
// Configure the SPI2 peripheral to trigger the DMA channel when the
// transmitter is empty.
//===========================================================================
void spi2_setup_dma(void)
{
  // Given.
  setup_dma();
  SPI2->CR2 |= SPI_CR2_TXDMAEN; // Transfer register empty DMA enable
}

//===========================================================================
// Enable the DMA channel.
//===========================================================================
void spi2_enable_dma(void)
{
  // Given.
  enable_dma();
}

//===========================================================================
// 4.4 SPI OLED Display
//===========================================================================
void init_spi1() {
  // PA5  SPI1_SCK
  // PA6  SPI1_MISO
  // PA7  SPI1_MOSI
  // PA15 SPI1_NSS

  // Enable port B, can write
  // 0x00004000 instead
  RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

  // Set PA5, 6, 7, 15 into AF mode.
  // Like earlier, they can use the
  // CMSIS calls.
  GPIOA->MODER &= ~0xc000fc00;
  GPIOA->MODER |=  0x8a00a800;

  // These pins default alternate
  // functions are the SPI function.
  // However, they can clear them out
  // if they want. It doesn't make a
  // difference.
  // Like earlier, they can use the
  // same CMSIS calls.
  GPIOA->AFR[0] &= ~0xfff00000;
  GPIOA->AFR[1] &= ~0xf0000000;

  // Turn on RCC clock, can write
  // 0x00001000 instead.
  RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

  // Turn off the channel for
  // configuration, can write 0x0040
  SPI1->CR1 &= ~SPI_CR1_SPE;

  // Turn baud rate to lowest,
  // can write 0x0038 instead
  SPI1->CR1 |= SPI_CR1_BR;

  // Set data size to 10 bit. Pay careful
  // attention to how they do it, as
  // they cannot write 0x0900 or clear
  // 0x0f00 since the chip is finnicky
  // with it's default here. They need
  // to write 0x0900 and THEN clear 0x0600.
  // It's possible they're using the CMSIS
  // identities, which looks like
  // ORRING (SPI_CR2_DS_3 | SPI_CR2_DS_0) and
  // clearing (SPI_CR2_DS_1 | SPI_CR2_DS_2).
  SPI1->CR2 |= 0x0900;
  SPI1->CR2 &= ~0x0600;

  // Turn on master mode, can write
  // 0x0004 instead
  SPI1->CR1 |= SPI_CR1_MSTR;

  // Enable SSOE and NSSP, can write
  // 0x000c instead
  SPI1->CR2 |= SPI_CR2_SSOE | SPI_CR2_NSSP;

  // Trigger a DMA transfer, can write
  // 0x0002 instead
  SPI1->CR2 |= SPI_CR2_TXDMAEN;

  // Turn the spi channel back on,
  // can write 0x0040 instead
  SPI1->CR1 |= SPI_CR1_SPE;

  //**** NOTE ****
  // After this block, if you put a
  // breakpoint here the registers should look
  // like this:
  // CR1 -> 0x007c
  // CR2 -> 0x090e
  //**** END ****

}

void spi_cmd(unsigned int data)
{
  // Given.
  while(!(SPI1->SR & SPI_SR_TXE)) {}
  SPI1->DR = data;
}
void spi_data(unsigned int data)
{
  // Given.
  spi_cmd(data | 0x200);
}
void spi1_init_oled()
{
  // Given.
  nano_wait(1000000);
  spi_cmd(0x38);
  spi_cmd(0x08);
  spi_cmd(0x01);
  nano_wait(2000000);
  spi_cmd(0x06);
  spi_cmd(0x02);
  spi_cmd(0x0c);
}
void spi1_display1(const char *string)
{
  // Given.
  spi_cmd(0x02);
  while(*string != '\0')
  {
      spi_data(*string);
      string++;
  }
}
void spi1_display2(const char *string)
{
  // Given.
  spi_cmd(0xc0);
  while(*string != '\0')
  {
      spi_data(*string);
      string++;
  }
}

//===========================================================================
// This is the 34-entry buffer to be copied into SPI1.
// Each element is a 16-bit value that is either character data or a command.
// Element 0 is the command to set the cursor to the first position of line 1.
// The next 16 elements are 16 characters.
// Element 17 is the command to set the cursor to the first position of line 2.
//===========================================================================
uint16_t display[34] = {
        0x002, // Command to set the cursor at the first position line 1
        0x200+'E', 0x200+'C', 0x200+'E', 0x200+'3', 0x200+'6', + 0x200+'2', 0x200+' ', 0x200+'i',
        0x200+'s', 0x200+' ', 0x200+'t', 0x200+'h', + 0x200+'e', 0x200+' ', 0x200+' ', 0x200+' ',
        0x0c0, // Command to set the cursor at the first position line 2
        0x200+'c', 0x200+'l', 0x200+'a', 0x200+'s', 0x200+'s', + 0x200+' ', 0x200+'f', 0x200+'o',
        0x200+'r', 0x200+' ', 0x200+'y', 0x200+'o', + 0x200+'u', 0x200+'!', 0x200+' ', 0x200+' ',
};

//===========================================================================
// Configure the proper DMA channel to be triggered by SPI1_TX.
// Set the SPI1 peripheral to trigger a DMA when the transmitter is empty.
//===========================================================================
void spi1_setup_dma(void)
{
  // Turn on DMA1
  RCC->AHBENR |= RCC_AHBENR_DMA1EN;

  // Turn off DMA
  // CPAR to SPI1 DR adr
  // CMAR to msg adr
  // 34 units in array
  // mem to per direction
  // Increment mem adr
  // no inc per adr
  // Set data size to 16b
  // Operate circularly
  // Configure DMA. They should be using channel 3.
  DMA1_Channel3->CCR &= ~DMA_CCR_EN;
  DMA1_Channel3->CPAR = (uint32_t) &(SPI1->DR);
  DMA1_Channel3->CMAR = (uint32_t) &(display);
  DMA1_Channel3->CNDTR = 34;
  DMA1_Channel3->CCR |= DMA_CCR_DIR;
  DMA1_Channel3->CCR |= DMA_CCR_MINC;
  DMA1_Channel3->CCR &= ~DMA_CCR_PINC;
  DMA1_Channel3->CCR |= 0x0500;
  DMA1_Channel3->CCR |= DMA_CCR_CIRC;

  //**** NOTE ****
  // After this task, these
  // hex codes should be visible if you put
  // in a breakpoint:
  // CCR  -> 0x05b0
  // CPAR -> 0x4001300C
  // CNDTR-> 0x00034
  // CMAR -> Varies depending on how the
  //         compiler organizes it. No set
  //         address. Should be in the
  //         0x20000000 range though, because
  //         that's where the memory is.
  //**** END ****
}

//===========================================================================
// Enable the DMA channel triggered by SPI1_TX.
//===========================================================================
void spi1_enable_dma(void)
{
  // Enable the DMA.
  DMA1_Channel3->CCR |= DMA_CCR_EN;

  //**** NOTE ****
  // After this task, the CCR hex code
  // should change to 0x05b1 if you put a
  // breakpoint here.
  //**** END ****
}


char middle_char(){
    char c = get_keypress();
    return c;

}


void print_middle(const char str[])
{
    const char *p = str;
    for(int i=0; i<8; i++) {
        if (*p == '\0') {
            msg[i] = (i<<8);
        } else {
            msg[i] = (i<<8) | font[*p & 0x7f] | (*p & 0x80);
            p++;
        }
    }
}

void shift_disp_right(char* str){
	char str_7 = str[7];
	char str_6 = str[6];
	char str_5 = str[5];
	str[6] = str_7;
	str[5] = str_6;
	str[4] = str_5;
}

//===========================================================================
// Queue function
//===========================================================================



void rand_queue()
{
  //display();
  //dequeue();
  for(int i =0; i<= sequence_len ; i++){
    int n = rand() % 16;
    enqueue(n);
  }
  //display();
  enqueue(69);
  //display();

  //printf("\n\nnumber first in queue is %d\n", num);
}

void enqueue(int item)
{
    struct node *nptr = malloc(sizeof(struct node));
    nptr->data = item;
    nptr->next = NULL;
    if (rear == NULL)
    {
        front = nptr;
        rear = nptr;
    }
    else
    {
        rear->next = nptr;
        rear = rear->next;
    }
}



int dequeue()
{
  int num = 0;
    if (front == NULL)
    {
        printf("\n\nqueue is empty \n");
    }
    else
    {
        struct node *temp;
        temp = front;
        front = front->next;
        printf("\n\n%d deleted", temp->data);
        num = temp -> data;
        free(temp);
    }
  return(num);
}

// AHHHHHHHH FUCK EVERYTHING
void clear_queue(){
	int n = keypress_num();
	//char c = '0';
	push_queue(0);
	push_queue(0);
//	pop_queue();
//	pop_queue();
/*
	int i = 0;
	//push_queue('\0');

	for(;;){
		c = pop_queue();
		//break;
		i += 1;
		push_queue(1);
		push_queue(2);
		if(c == NULL){
			if((i %2) != 0){
				//pop_queue();
				break;
			}
			//push_queue(0);

			break;
		}


	}
*/


}



//===========================================================================
// GAME functions
//===========================================================================
void display_rand(char* string){
    for(;;){
    	int num_queue = dequeue();
    	if(num_queue == 69){
    		break;
    	}


    	char rand_c = dig_char[num_queue];


    	string[6] = rand_c;
    	print_middle(string);
    	nano_wait(700000000);
    	string[6] = ' ';
    	print_middle(string);
    	nano_wait(200000000);



    	enqueue(num_queue);
    }
    string[5] = 'G';
    string[6] = 'O';


    print_middle(string);
    nano_wait(500000000);
    string[5] = ' ';
    string[6] = ' ';

    print_middle(string);
}

void play_SMT(char* string){
	int i = 0;
	for(;;){
			char c = middle_char();

			// used to push data from digit 4 -7 adn repeat 1234 -> 5234 -> 5634 ...
			//int digit = i % 4;
			shift_disp_right(string);
			string[7] = c;


			print_middle(string);

			// gets number from queue and then changes it to char.
			int num_ran = dequeue();

			if(c != dig_char[num_ran]){
				print_middle("too bad");
				break;
			}
			else if(i == sequence_len){
				nano_wait(500000000);
				print_middle("yay  yay");
				break;
			}
			i++;


		}
}

//===========================================================================
// Main function
//===========================================================================

int main(void) {
	 enable_ports();
	    init_tim7();
	    setup_bb();
	    init_spi2();
	    setup_dma();
	    enable_dma();
	    init_tim15();

		rand_queue();

	    char string[9] = "        ";
	    print_middle(string);

	    //char rand_string[] = "123456789";
	    int i = 0;
	    display_rand(string);
	    play_SMT(string);

	    //clear_queue();


}
